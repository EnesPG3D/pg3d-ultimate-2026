<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ULTRA META WIKI FINAL</title>

<style>
:root{
--bg:#0f0f1a;
--card:#1a1a2e;
--neon:#00f5ff;
--accent:#ff00cc;
--text:#ffffff;
}

*{box-sizing:border-box;margin:0;padding:0;font-family:Arial}
body{background:var(--bg);color:var(--text);transition:.3s}

header{
padding:15px;
text-align:center;
font-size:22px;
background:#111;
box-shadow:0 0 15px #000;
}

.controls{
padding:10px;
text-align:center;
}

button,input,select{
margin:4px;
padding:6px;
border-radius:6px;
border:none;
cursor:pointer;
}

#grid{
display:grid;
grid-template-columns:repeat(auto-fill,minmax(220px,1fr));
gap:10px;
padding:15px;
}

.card{
background:var(--card);
padding:10px;
border-radius:10px;
transition:.3s;
cursor:pointer;
}

.card:hover{
box-shadow:0 0 15px var(--neon);
transform:translateY(-3px);
}

.panel{
background:#111;
padding:12px;
margin:10px;
border-radius:10px;
}

canvas{
background:#000;
margin-top:10px;
}

.tier-S{border-left:5px solid gold}
.tier-A{border-left:5px solid lime}
.tier-B{border-left:5px solid cyan}
.tier-C{border-left:5px solid orange}
.tier-D{border-left:5px solid red}

.small{font-size:12px;opacity:.7}
.hidden{display:none}
</style>
</head>
<body>

<header>ULTRA META WIKI FINAL - GITHUB READY</header>

<div class="controls">
<input type="text" id="search" placeholder="Search">
<select id="tierFilter">
<option value="">All Tier</option>
<option>S</option><option>A</option><option>B</option>
<option>C</option><option>D</option>
</select>
<select id="elementFilter">
<option value="">All Element</option>
<option>None</option>
<option>Fire</option>
<option>Ice</option>
<option>Poison</option>
</select>
<button onclick="sortMeta()">Sort Meta</button>
<button onclick="randomBuild()">Random</button>
<button onclick="favoritesOnly()">Fav Only</button>
<button onclick="toggleTheme()">Theme</button>
<button onclick="simulatePatch()">Patch</button>
</div>

<div id="grid"></div>

<div class="panel">
<h3>Loadout Builder (3 Slot)</h3>
<div id="loadout"></div>
<p id="combined"></p>
<button onclick="clearLoadout()">Clear</button>
<button onclick="upgradeLoadout()">Upgrade +5</button>
</div>

<div class="panel">
<h3>Top 10 Meta</h3>
<ol id="top"></ol>
</div>

<div class="panel">
<h3>Stats Graph</h3>
<canvas id="graph" width="600" height="200"></canvas>
<p id="performance" class="small"></p>
<p id="fps" class="small"></p>
</div>

<script>
const elements=["None","Fire","Ice","Poison"];
let weapons=[];
let favorites=JSON.parse(localStorage.getItem("favorites"))||[];
let loadout=[];
let patchMultiplier=1;

function generateWeapons(n){
for(let i=1;i<=n;i++){
let damage=Math.random()*80+20;
let fireRate=Math.random()*2+0.5;
let reload=Math.random()*2+1;
let crit=Math.random()*0.5;
let armorPen=Math.random()*0.4;
let accuracy=Math.random()*0.3+0.7;
let weight=Math.random()*10+5;
let element=elements[Math.floor(Math.random()*elements.length)];

let trueDPS=calcDPS(damage,fireRate,reload,crit,armorPen,accuracy,element);
let metaScore=Math.min(100,(trueDPS/180)*100);

weapons.push({
id:i,name:"Weapon "+i,
damage,fireRate,reload,crit,armorPen,accuracy,weight,element,
trueDPS,metaScore,level:1
});
}
assignTier();
}

function calcDPS(d,f,r,c,a,acc,e){
let base=d*f;
let critD=base*(1+c);
let reloadP=1/(r*0.6);
let armorB=1+a;
let elementB=e==="Fire"?1.1:e==="Ice"?1.05:e==="Poison"?1.08:1;
return critD*reloadP*armorB*elementB*acc*patchMultiplier;
}

function assignTier(){
weapons.forEach(w=>{
if(w.metaScore>=85) w.tier="S";
else if(w.metaScore>=70) w.tier="A";
else if(w.metaScore>=55) w.tier="B";
else if(w.metaScore>=40) w.tier="C";
else w.tier="D";
});
}

function render(list){
let start=performance.now();
let grid=document.getElementById("grid");
grid.innerHTML="";
let slice=list.slice(0,400);
slice.forEach(w=>{
let d=document.createElement("div");
d.className="card tier-"+w.tier;
d.innerHTML=`
<h4>${w.name} <span class="small">Lv.${w.level}</span></h4>
<p>DPS: ${w.trueDPS.toFixed(1)}</p>
<p>Meta: ${w.metaScore.toFixed(1)} (${w.tier})</p>
<p>Mobility: ${(100-w.weight*2).toFixed(0)}</p>
<p>Element: ${w.element}</p>
<button onclick="addLoadout(${w.id})">Add</button>
<button onclick="toggleFav(${w.id})">Fav</button>
`;
grid.appendChild(d);
});
let end=performance.now();
document.getElementById("performance").innerText=
"Render: "+(end-start).toFixed(2)+"ms";
}

function sortMeta(){
weapons.sort((a,b)=>b.metaScore-a.metaScore);
render(weapons);
updateTop();
}

function addLoadout(id){
if(loadout.length<3){
let w=weapons.find(x=>x.id===id);
loadout.push(w);
updateLoadout();
}
}

function updateLoadout(){
let div=document.getElementById("loadout");
div.innerHTML="";
let total=0,mob=0;
loadout.forEach(w=>{
div.innerHTML+=w.name+"<br>";
total+=w.trueDPS;
mob+=100-w.weight*2;
});
let synergy=1+(loadout.length*0.05);
total*=synergy;
document.getElementById("combined").innerText=
"Combined DPS: "+total.toFixed(1)+" | Mobility: "+mob.toFixed(0);
drawGraph(loadout);
}

function clearLoadout(){loadout=[];updateLoadout()}

function upgradeLoadout(){
loadout.forEach(w=>{
w.level+=5;
w.damage*=1.1;
w.trueDPS=calcDPS(w.damage,w.fireRate,w.reload,w.crit,w.armorPen,w.accuracy,w.element);
w.metaScore=Math.min(100,(w.trueDPS/180)*100);
});
assignTier();
render(weapons);
updateLoadout();
updateTop();
}

function toggleFav(id){
if(favorites.includes(id)) favorites=favorites.filter(x=>x!==id);
else favorites.push(id);
localStorage.setItem("favorites",JSON.stringify(favorites));
}

function favoritesOnly(){
render(weapons.filter(w=>favorites.includes(w.id)));
}

function randomBuild(){
loadout=[];
for(let i=0;i<3;i++)
loadout.push(weapons[Math.floor(Math.random()*weapons.length)]);
updateLoadout();
}

function updateTop(){
let top=weapons.slice().sort((a,b)=>b.metaScore-a.metaScore).slice(0,10);
let ol=document.getElementById("top");
ol.innerHTML="";
top.forEach(w=>ol.innerHTML+="<li>"+w.name+" ("+w.metaScore.toFixed(1)+")</li>");
}

function drawGraph(list){
let c=document.getElementById("graph");
let ctx=c.getContext("2d");
ctx.clearRect(0,0,c.width,c.height);
list.forEach((w,i)=>{
ctx.fillStyle="cyan";
ctx.fillRect(i*200+80,200-w.trueDPS/2,50,w.trueDPS/2);
});
}

function toggleTheme(){
let dark=document.body.style.background!=="white";
if(dark){
document.body.style.background="white";
document.body.style.color="black";
}else{
document.body.style.background="#0f0f1a";
document.body.style.color="white";
}
}

function simulatePatch(){
patchMultiplier=patchMultiplier===1?0.9:1;
weapons.forEach(w=>{
w.trueDPS=calcDPS(w.damage,w.fireRate,w.reload,w.crit,w.armorPen,w.accuracy,w.element);
w.metaScore=Math.min(100,(w.trueDPS/180)*100);
});
assignTier();
render(weapons);
updateTop();
}

document.getElementById("search").addEventListener("input",e=>{
let val=e.target.value.toLowerCase();
render(weapons.filter(w=>w.name.toLowerCase().includes(val)));
});

document.getElementById("tierFilter").addEventListener("change",e=>{
let v=e.target.value;
if(!v) render(weapons);
else render(weapons.filter(w=>w.tier===v));
});

document.getElementById("elementFilter").addEventListener("change",e=>{
let v=e.target.value;
if(!v) render(weapons);
else render(weapons.filter(w=>w.element===v));
});

/* FPS */
let frames=0,last=performance.now();
function fpsLoop(){
frames++;
let now=performance.now();
if(now-last>=1000){
document.getElementById("fps").innerText="FPS: "+frames;
frames=0;
last=now;
}
requestAnimationFrame(fpsLoop);
}
fpsLoop();

generateWeapons(750);
render(weapons);
updateTop();
</script>

</body>
</html>
